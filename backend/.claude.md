# Claude Code Rules - Backend (Go)

## Project Structure
```
/backend
  /cmd/api          - Entry points (main.go, router setup)
  /internal         - Private packages (not importable by external code)
    /auth           - Authentication & authorization
    /sports         - Sports management
    /venues         - Venue management
    /leagues        - League submissions and drafts
  /pkg              - Public packages (if needed for external clients)
  /supabase/migrations - Database migration SQL files
```

## Patterns

### Service/Handler/Repository Pattern
```go
// Repository: Data access layer
type RepositoryInterface interface {
  GetUser(id string) (*User, error)
  CreateUser(...) error
}

// Service: Business logic
type Service struct {
  repo RepositoryInterface
}
func (s *Service) RegisterUser(...) error { ... }

// Handler: HTTP handlers
type Handler struct {
  service *Service
  validator *validator.Validate
}
func (h *Handler) Register(w http.ResponseWriter, r *http.Request) { ... }
```

### Error Handling
- Wrap errors with context: `return fmt.Errorf("operation: %w", err)`
- For Clerk API errors, check for `*clerk.APIErrorResponse` and extract trace ID
- Log errors with context before returning
- Use slog: `slog.Error("operation failed", "userID", id, "err", err)`

### Context Management
- Always use context with timeout for external API calls (5s default for Clerk)
- Pattern:
```go
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
```

### API Routes (Chi Router)
- Organize by domain in handler `RegisterRoutes(r chi.Router)`
- Public routes first, then protected routes with middleware
- Admin routes in separate group with `RequireAdmin` middleware
- Pattern:
```go
r.Route("/auth", func(r chi.Router) {
  r.Post("/register", h.Register)  // Public
  r.Group(func(r chi.Router) {
    r.Use(JWTMiddleware)
    r.Get("/user/{userID}", h.GetUser)  // Protected
  })
})
```

### Middleware
- JWT validation extracts user ID and sets `X-Clerk-User-ID` header
- Downstream handlers read from headers (no additional context passing)
- Role-based access: `RequireAdmin(authService)` checks user role via database
- Best effort approach: non-critical failures log but don't break flow

### Testing
- Test files: `*_test.go` in same package
- Table-driven tests for multiple scenarios
- Mock interfaces using mockery or manual mocks

### Clerk Integration
- Use Clerk SDK instead of HTTP calls
- Always handle `*clerk.APIErrorResponse` separately for trace IDs
- Metadata syncing: only include role (organization data is managed separately in database)
- Email verification: Clerk's native field is source of truth
- Environment variables: `CLERK_SECRET_KEY`, `SKIP_EMAIL_VERIFICATION` (dev-only)
- Organization context is NOT stored in Clerk metadata - it comes from URL path on frontend

### Models
- Define in `models.go` per package
- Use validation tags: `validate:"required,email"`
- Keep fields public (PascalCase) for JSON marshaling
- Add comments for exported types

### Logging
- Always log errors with context
- Use debug logs for flow tracing
- Pattern: `slog.Error("operation failed", "userID", id, "statusCode", 400, "err", err)`

### Comments
- Export comments on types/functions: `// User represents...`
- Inline comments for "why" decisions: `// Best effort - don't fail registration if metadata sync fails`
- Keep concise, not redundant

### Optional/Nullable Fields
- Use pointers for optional fields in models: `*string`, `*int`, `*float64`, `*time.Time`
- Reason: allows distinction between zero value and null in database/JSON
- Create helper functions for nullable values in tests:
```go
func stringPtr(s string) *string { return &s }
func intPtr(i int) *int { return &i }
```

### Extracting URL Parameters and Headers
- Chi URL params: `chi.URLParam(r, "paramName")`
- Headers: `r.Header.Get("X-Clerk-User-ID")`
- Query params: `r.URL.Query().Get("paramName")`
- Pattern:
```go
userID := r.Header.Get("X-Clerk-User-ID")
if userID == "" {
  http.Error(w, "Unauthorized", http.StatusUnauthorized)
  return
}
id := chi.URLParam(r, "id")
```

### HTTP Response Patterns
- Set content type before writing body: `w.Header().Set("Content-Type", "application/json")`
- Write status code before body: `w.WriteHeader(http.StatusOK)`
- Use `json.NewEncoder(w).Encode(response)` for marshaling
- Common status codes:
  - 200 OK, 201 Created (POST success), 204 No Content
  - 400 Bad Request, 401 Unauthorized, 403 Forbidden
  - 404 Not Found, 409 Conflict
  - 500 Internal Server Error
- Pattern:
```go
w.Header().Set("Content-Type", "application/json")
w.WriteHeader(http.StatusCreated)
json.NewEncoder(w).Encode(response)
```

### JSONB and Complex Data Types in PostgreSQL
- Use JSONB for flexible/variable-shaped data (e.g., draft_data map, game_occurrences array)
- Implement `Scan()` and `Value()` interfaces for custom types:
```go
// Scan implements sql.Scanner for JSONB unmarshaling
func (g *GameOccurrences) Scan(value interface{}) error {
  bytes, ok := value.([]byte)
  if !ok { return nil }
  return json.Unmarshal(bytes, &g)
}

// Value implements driver.Valuer for JSONB marshaling
func (g GameOccurrences) Value() (driver.Value, error) {
  return json.Marshal(g)
}
```
- Reason: allows type-safe Go structs while storing flexible JSON in database

### Enums as Type-Safe Constants
- Define as `type Status string` with const values
- Add validation method: `func (s Status) IsValid() bool { switch s {...} }`
- Add string method: `func (s Status) String() string { return string(s) }`
- Use in database columns as PostgreSQL ENUM type in migrations
- Pattern:
```go
type LeagueStatus string
const (
  LeagueStatusPending  LeagueStatus = "pending"
  LeagueStatusApproved LeagueStatus = "approved"
)
func (l LeagueStatus) IsValid() bool { ... }
```

### Organization Onboarding Architecture
- **Separated Concerns**: Auth package handles only user accounts, organizations package handles org management
- **Lean User Table**: Users contain only: id, email, role (platform role, not org-specific), login tracking, is_active
- **Many-to-Many Relationships**: `user_organizations` junction table tracks which orgs a user belongs to
- **Junction Table Schema**:
  - user_id (FK to users)
  - org_id (FK to organizations, UUID)
  - role_in_org (owner, admin, member - org-specific role)
  - is_active (soft delete capability)
  - joined_at, created_at, updated_at timestamps
- **Organization Context in Frontend**: Org ID passed via URL path (/dashboard/{orgId}), not stored in user session
- **Service Dependencies**: Packages that need org access should depend on `organizations.Service`, not repo directly
- **Access Control**: Services verify user org access via `orgService.VerifyUserOrgAccess(userID, orgId)` before operations

### UUID for Organization IDs
- Organizations use UUIDs instead of sequential integers (prevents enumeration attacks)
- UUID generated server-side in repository: `uuid.New().String()`
- All org_id fields in related tables use UUID (string type)
- Pattern:
```go
// In repository.CreateOrganization
orgID := uuid.New().String()
// Pass to database, return to service
```

### Service with Multiple Dependencies
- Services can depend on other services (e.g., leagues depends on organizations and auth)
- Inject dependencies via constructor:
```go
type Service struct {
  repo        RepositoryInterface
  orgService  *organizations.Service
  authService *auth.Service
}

func NewService(repo RepositoryInterface, orgService *organizations.Service, authService *auth.Service) *Service {
  return &Service{
    repo:        repo,
    orgService:  orgService,
    authService: authService,
  }
}
```
- Use injected services for business logic validation before calling own repo
- Pattern (example from leagues):
  - CreateLeague: verify user has org access via orgService
  - ApproveLeague: verify user is admin via authService

### Organization Access Verification Pattern
- Always verify user has access to org before operations:
```go
err := s.orgService.VerifyUserOrgAccess(userID, orgID)
if err != nil {
  return fmt.Errorf("user does not have access to this organization: %w", err)
}
```
- Handler extracts userID from header, passes to service
- Service handles all access control logic
- Repository only performs data operations

### Direct Join (MVP Pattern)
- For MVP, users can directly join any organization
- In future, can implement request-based or invite-based joins
- Current LinkUserToOrganization uses UPSERT to handle re-joining
- When creating org, creator is automatically linked as "owner" role

### Draft/Save-as-You-Go Feature
- Store draft separately (e.g., `table_drafts`) with minimal schema
- Use JSONB for flexible draft_data
- Add UNIQUE constraint on org_id for single draft per org
- Use PostgreSQL UPSERT pattern (ON CONFLICT DO UPDATE) for atomic save:
```sql
INSERT INTO table_drafts (org_id, draft_data, ...)
VALUES ($1, $2, ...)
ON CONFLICT (org_id) DO UPDATE
SET draft_data = $2, updated_at = $3
RETURNING id
```

### Calculation Logic and Rounding
- For price calculations, use `math.Ceil()` to round up when dividing costs
- Example: team cost $100 / 3 players = $33.33 â†’ rounds to $34
- Store both input and calculated values (e.g., `pricing_amount` and `pricing_per_player`)
- Pattern:
```go
import "math"
pricePerPlayer := math.Ceil(totalCost / float64(minPlayers))
```

### Database Migrations
- Use timestamps in migration filenames: `20251031130000_description.sql`
- Include comments on columns and tables for documentation
- Create indexes for frequently-filtered columns
- Use IF NOT EXISTS for idempotent migrations (safe for re-runs)
- Pattern:
```sql
CREATE TYPE status_enum AS ENUM ('pending', 'approved', 'rejected');
ALTER TABLE items ADD COLUMN IF NOT EXISTS status status_enum DEFAULT 'pending';
COMMENT ON COLUMN items.status IS 'Status description here';
CREATE INDEX IF NOT EXISTS idx_items_status ON items (status);
```

### Input Validation in Handlers
- Validate request struct with `h.validator.Struct(req)`
- Handle validation errors by extracting ValidationErrors:
```go
err = h.validator.Struct(req)
if err != nil {
  validationErrors := err.(validator.ValidationErrors)
  http.Error(w, "Validation failed: "+validationErrors.Error(), http.StatusBadRequest)
  return
}
```

### Testing Patterns with Mocks
- Create mock repository implementing the interface
- Use in-memory storage (maps) for test data
- Create test helper functions for common setup
- Pattern:
```go
type MockRepository struct {
  items map[int]*Item
  nextID int
}
func (m *MockRepository) Create(item *Item) error {
  item.ID = m.nextID
  m.items[m.nextID] = item
  m.nextID++
  return nil
}
```

### Authorization in Handlers
- Handlers should NOT do complex auth logic
- Handlers extract userID from header: `r.Header.Get("X-Clerk-User-ID")`
- Pass userID to service methods that need to verify access
- Service does the actual verification via injected service dependencies
- Pattern:
```go
func (h *Handler) CreateLeague(w http.ResponseWriter, r *http.Request) {
  userID := r.Header.Get("X-Clerk-User-ID")  // Extract from header
  var req CreateLeagueRequest
  json.NewDecoder(r.Body).Decode(&req)
  h.validator.Struct(req)  // Validate request

  // Service handles business logic including org access verification
  league, err := h.service.CreateLeague(userID, &req)
}
```
- Service methods that need org context should receive userID and orgID
- Service calls orgService.VerifyUserOrgAccess before proceeding

### Organizations Package Structure
- **models.go**: Organization, UserOrganization, CreateOrganizationRequest
- **repository.go**: Data access interface and implementation
  - Must implement interface for dependency injection
  - Key methods: CreateOrganization, UserHasAccessToOrg, GetUserOrganizations, etc.
- **service.go**: Business logic layer
  - Depends on RepositoryInterface (not concrete repo)
  - Wraps repo methods with validation and error handling
  - Can be injected into other services
- **handler.go** (to be created): HTTP endpoints for org operations
  - Create org endpoint (during onboarding)
  - Get user organizations
  - Get all organizations (admin only)
  - Join organization (direct join for MVP)

## Dependencies
- `chi/v5` - HTTP router and middleware
- `pgx/v5` - PostgreSQL driver and connection pool
- `clerk/clerk-sdk-go/v2` - Clerk authentication (via JWT)
- `go-playground/validator/v10` - Struct validation for requests
- `svix/svix-go` - Webhook verification
- `google/uuid` - UUID generation for organization IDs

## Development
- Run: `go run ./cmd/api`
- Build: `go build -o ./backend/tmp/main ./cmd/api`
- Test: `go test ./...`
