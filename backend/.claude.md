# Claude Code Rules - Backend (Go)

## Project Structure
```
/backend
  /cmd/api          - Entry points (main.go, router setup)
  /internal         - Private packages (not importable by external code)
    /auth           - Authentication & authorization
    /sports         - Sports management
    /venues         - Venue management
  /pkg              - Public packages (if needed for external clients)
```

## Patterns

### Service/Handler/Repository Pattern
```go
// Repository: Data access layer
type RepositoryInterface interface {
  GetUser(id string) (*User, error)
  CreateUser(...) error
}

// Service: Business logic
type Service struct {
  repo RepositoryInterface
}
func (s *Service) RegisterUser(...) error { ... }

// Handler: HTTP handlers
type Handler struct {
  service *Service
  validator *validator.Validate
}
func (h *Handler) Register(w http.ResponseWriter, r *http.Request) { ... }
```

### Error Handling
- Wrap errors with context: `return fmt.Errorf("operation: %w", err)`
- For Clerk API errors, check for `*clerk.APIErrorResponse` and extract trace ID
- Log errors with context before returning
- Use slog: `slog.Error("operation failed", "userID", id, "err", err)`

### Context Management
- Always use context with timeout for external API calls (5s default for Clerk)
- Pattern:
```go
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
```

### API Routes (Chi Router)
- Organize by domain in handler `RegisterRoutes(r chi.Router)`
- Public routes first, then protected routes with middleware
- Admin routes in separate group with `RequireAdmin` middleware
- Pattern:
```go
r.Route("/auth", func(r chi.Router) {
  r.Post("/register", h.Register)  // Public
  r.Group(func(r chi.Router) {
    r.Use(JWTMiddleware)
    r.Get("/user/{userID}", h.GetUser)  // Protected
  })
})
```

### Middleware
- JWT validation extracts user ID and sets `X-Clerk-User-ID` header
- Downstream handlers read from headers (no additional context passing)
- Role-based access: `RequireAdmin(authService)` checks user role via database
- Best effort approach: non-critical failures log but don't break flow

### Testing
- Test files: `*_test.go` in same package
- Table-driven tests for multiple scenarios
- Mock interfaces using mockery or manual mocks

### Clerk Integration
- Use Clerk SDK instead of HTTP calls
- Always handle `*clerk.APIErrorResponse` separately for trace IDs
- Metadata syncing: include role, organizationName
- Email verification: Clerk's native field is source of truth
- Environment variables: `CLERK_SECRET_KEY`, `SKIP_EMAIL_VERIFICATION` (dev-only)

### Models
- Define in `models.go` per package
- Use validation tags: `validate:"required,email"`
- Keep fields public (PascalCase) for JSON marshaling
- Add comments for exported types

### Logging
- Always log errors with context
- Use debug logs for flow tracing
- Pattern: `slog.Error("operation failed", "userID", id, "statusCode", 400, "err", err)`

### Comments
- Export comments on types/functions: `// User represents...`
- Inline comments for "why" decisions: `// Best effort - don't fail registration if metadata sync fails`
- Keep concise, not redundant

## Dependencies
- `chi/v5` - Router
- `clerk/clerk-sdk-go/v2` - Clerk authentication
- `go-playground/validator/v10` - Struct validation
- `svix/svix-go` - Webhook verification

## Development
- Run: `go run ./cmd/api`
- Build: `go build -o ./backend/tmp/main ./cmd/api`
- Test: `go test ./...`
