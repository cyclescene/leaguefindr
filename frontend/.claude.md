# Claude Code Rules - Frontend (Next.js 16)

## Project Structure
```
/frontend/dashboard
  /app                - App router pages and layouts
    /(admin)          - Admin route group (requires admin role)
    /(auth)           - Auth pages (signin, signup)
  /components         - React components
    /admin            - Admin-specific components
    /forms            - Form components
  /lib                - Utilities
    /schemas          - Zod/validation schemas
  /types              - TypeScript type definitions
  proxy.ts            - Middleware for auth routing
  tsconfig.json       - TypeScript config
```

## Patterns

### App Router Organization
- Route groups: `(admin)`, `(auth)` - logical grouping, not in URL
- Dynamic routes: `[param]` for URL segments
- Middleware: `proxy.ts` handles auth before routes
- Pattern:
```
/app
  /(admin)/admin/page.tsx       → /admin
  /(auth)/signin/page.tsx       → /signin
  /dashboard/page.tsx           → /dashboard
```

### Authentication Flow (Middleware)
- `proxy.ts` orchestrates auth routing
- Read from `sessionClaims` (no API calls)
- Flow:
  1. No userId → redirect to /signin
  2. userId + !emailVerified → redirect to /verify-email
  3. userId + verified + admin → allow /admin
  4. userId + verified + user → allow /dashboard
- Clerk handles actual email verification (frontend reads from native field)

### React Hook Form + Zod Validation

#### Schema Definition
- Define schemas in `lib/schemas/`
- Use Zod for validation and type inference
- Pattern:
```ts
// lib/schemas/auth.ts
import { z } from 'zod'

export const registerSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  organizationName: z.string().min(1, 'Organization name is required')
})

export type RegisterFormData = z.infer<typeof registerSchema>
```

#### Form Component with Validation
- Use `useForm` hook with Zod resolver
- Register fields and handle submission
- Display validation errors
- Pattern:
```tsx
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { registerSchema, type RegisterFormData } from '@/lib/schemas/auth'

export function RegisterForm() {
  const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm<RegisterFormData>({
    resolver: zodResolver(registerSchema)
  })

  const onSubmit = async (data: RegisterFormData) => {
    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })

      if (!response.ok) {
        throw new Error('Registration failed')
      }

      // Handle success
    } catch (error) {
      console.error('Submit error:', error)
      // Show error to user
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <input
          {...register('email')}
          type="email"
          placeholder="Email"
        />
        {errors.email && <span className="text-red-500">{errors.email.message}</span>}
      </div>

      <div>
        <input
          {...register('organizationName')}
          type="text"
          placeholder="Organization"
        />
        {errors.organizationName && <span className="text-red-500">{errors.organizationName.message}</span>}
      </div>

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Registering...' : 'Register'}
      </button>
    </form>
  )
}
```

#### Validation Features
- Field-level validation: errors display inline
- Real-time validation: set `mode: 'onChange'` if needed
- Custom validation: add to Zod schema
- Async validation: use `.refine()` for API checks
- Error messages: use Zod message parameter for user-friendly text

#### Form Submission Patterns
- Prevent duplicate submissions: use `isSubmitting` state
- Show loading state while submitting
- Handle both success and error states
- Use `try/catch` for error handling
- Redirect or reset form on success

### Components
- Functional components with TypeScript
- Props interface: `interface ComponentProps { ... }`
- Pattern:
```tsx
interface ButtonProps {
  label: string;
  onClick: () => void;
  isLoading?: boolean;
}

export function Button({ label, onClick, isLoading }: ButtonProps) {
  return (
    <button onClick={onClick} disabled={isLoading}>
      {isLoading ? 'Loading...' : label}
    </button>
  )
}
```

### Types & Interfaces
- Define in `types/` folder
- Extend Clerk types in `clerk.d.ts`:
```ts
declare global {
  interface CustomJwtSessionClaims extends JwtPayload {
    role?: "admin" | "user";
    emailVerified?: boolean;
  }
}
```
- Use strict TypeScript (no `any`)

### Styling
- Use Tailwind CSS for styling
- Component-level styling: className props or CSS modules
- Dark mode: configure in tailwind.config
- Responsive: mobile-first with `sm:`, `md:`, `lg:` prefixes

### API Communication
- API routes in `/app/api/`
- Fetch with proper error handling
- Always set `Content-Type: application/json`
- Handle auth errors (401 → redirect to /signin)

### Environment Variables
- `NEXT_PUBLIC_*` for client-side
- `.env.local` for secrets (never commit)
- Required: `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY`, `CLERK_SECRET_KEY`

### State Management
- Prefer React hooks (useState, useContext)
- Props for component communication
- Context for global state (auth, theme)
- React Hook Form for form state management
- No Redux/Zustand unless necessary

### Performance
- Code splitting: automatic with Next.js app router
- Image optimization: use `next/image`
- API calls: only when necessary
- Session claims: avoid redundant Clerk API calls

### Testing
- Component tests: React Testing Library
- E2E tests: Playwright
- Test auth flows with Clerk's test mode

### Middleware (proxy.ts)
- Runs on every request
- Read from `sessionClaims` only (no API calls)
- Set up route matchers for protected routes
- Example:
```ts
const isProtectedRoute = createRouteMatcher(['/', '/admin(.*)'])
```

### Comments
- Explain "why" not "what"
- Link to relevant docs for non-obvious patterns
- Component purpose at top: `// AdminDashboard displays metrics for admins`

## Dependencies
- `next@16` - Framework
- `@clerk/nextjs` - Authentication
- `react-hook-form` - Form state management
- `@hookform/resolvers` - Zod integration
- `zod` - Validation schemas
- `tailwindcss` - Styling
- `react` - UI library

## Development
- Install: `pnpm install`
- Dev: `pnpm dev`
- Build: `pnpm build`
- Package manager: **pnpm** (not npm/yarn)

## Type Safety
- Extend Clerk types for custom claims
- Use `z.infer<typeof schema>` for form type inference from Zod
- No `as any` unless absolutely necessary
- Use `satisfies` for type narrowing when helpful
- Leverage TypeScript strict mode

## Best Practices
- Keep components small and focused
- Lift state up when multiple components need it
- Use composition over prop drilling
- Error boundaries for graceful failures
- Loading states for async operations
- Validate on both client (Zod) and server (backend)
