# Claude Code Rules - Frontend (Next.js 16)

## Project Structure
```
/frontend/dashboard
  /app                - App router pages and layouts
    /(admin)          - Admin route group (requires admin role)
    /(auth)           - Auth pages (signin, signup)
  /components         - React components
    /admin            - Admin-specific components
    /forms            - Form components
  /lib                - Utilities
    /schemas          - Zod/validation schemas
  /types              - TypeScript type definitions
  proxy.ts            - Middleware for auth routing
  tsconfig.json       - TypeScript config
```

## Patterns

### App Router Organization
- Route groups: `(admin)`, `(auth)` - logical grouping, not in URL
- Dynamic routes: `[param]` for URL segments
- Middleware: `proxy.ts` handles auth before routes
- Pattern:
```
/app
  /(admin)/admin/page.tsx       → /admin
  /(auth)/signin/page.tsx       → /signin
  /dashboard/page.tsx           → /dashboard
```

### Authentication Flow (Middleware)
- `proxy.ts` orchestrates auth routing
- Read from `sessionClaims` (no API calls)
- Flow:
  1. No userId → redirect to /signin
  2. userId + !emailVerified → redirect to /verify-email
  3. userId + verified + admin → allow /admin
  4. userId + verified + user → allow /dashboard
- Clerk handles actual email verification (frontend reads from native field)

### Complex Forms with Multiple Sections

#### Multi-Section Form Pattern
- Break large forms into logical sections with `border-t pt-6` styling
- Each section has a heading (`h3`) and groups related fields
- Use `grid grid-cols-1 md:grid-cols-2 gap-4` for field layout on same row
- Pattern:
```tsx
<form onSubmit={handleSubmit(onSubmit)} className="space-y-6 w-full">
  {/* Section: League Information */}
  <div className="border-t pt-6">
    <h3 className="text-lg font-semibold text-gray-900 mb-4">League Information</h3>
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
      {/* Fields here */}
    </div>
  </div>

  {/* Section: Pricing */}
  <div className="border-t pt-6">
    <h3 className="text-lg font-semibold text-gray-900 mb-4">Pricing</h3>
    {/* Fields and calculations */}
  </div>

  {/* Status/Error Messages */}
  {draftSaveStatus && <div className="rounded-md bg-green-50 p-4">...</div>}

  {/* Button Group */}
  <div className="flex gap-3">
    <Button type="button" onClick={handleSaveDraft} variant="outline" className="flex-1">
      Save Draft
    </Button>
    <Button type="submit" className="flex-1">
      Submit
    </Button>
  </div>
</form>
```

#### Dynamic Array Fields Pattern
- Use separate state for dynamic array (e.g., `gameOccurrences`)
- Sync state with form using `setValue()` from useForm
- Add/remove items with buttons using lucide icons (Plus, X)
- Pattern:
```tsx
const [gameOccurrences, setGameOccurrences] = useState<GameOccurrence[]>([])

const handleAddGameOccurrence = () => {
  const updated = [...gameOccurrences, newOccurrence]
  setGameOccurrences(updated)
  setValue('game_occurrences', updated)
}

const handleRemoveGameOccurrence = (index: number) => {
  const updated = gameOccurrences.filter((_, i) => i !== index)
  setGameOccurrences(updated)
  setValue('game_occurrences', updated)
}
```

#### Date Field Patterns
- Store date state separately from form for DatePicker component
- Use `format()` and `parse()` from date-fns for string/Date conversion
- Always format dates as 'yyyy-MM-dd' for backend consistency
- Pattern:
```tsx
const [seasonStartDate, setSeasonStartDate] = useState<Date | undefined>()

const handleSeasonStartDateChange = (date: Date | undefined) => {
  setSeasonStartDate(date)
  if (date) {
    setValue('season_start_date', format(date, 'yyyy-MM-dd'))
  }
}

// On draft load:
const parsedDate = parse(value, 'yyyy-MM-dd', new Date())
setSeasonStartDate(parsedDate)
```

### React Hook Form + Zod Validation

#### Schema Definition
- Define schemas in `lib/schemas/`
- Use Zod for validation and type inference
- Pattern:
```ts
// lib/schemas/auth.ts
import { z } from 'zod'

export const registerSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  organizationName: z.string().min(1, 'Organization name is required')
})

export type RegisterFormData = z.infer<typeof registerSchema>
```

#### Form Component with Validation
- Use `useForm` hook with Zod resolver
- Register fields and handle submission
- Use shadcn/ui components (Input, Label, Button)
- Display validation errors inline
- Pattern:
```tsx
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { registerSchema, type RegisterFormData } from '@/lib/schemas/auth'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Button } from '@/components/ui/button'

export function RegisterForm() {
  const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm<RegisterFormData>({
    resolver: zodResolver(registerSchema)
  })

  const onSubmit = async (data: RegisterFormData) => {
    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })

      if (!response.ok) {
        throw new Error('Registration failed')
      }

      // Handle success
    } catch (error) {
      console.error('Submit error:', error)
      // Show error to user
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="email">Email</Label>
        <Input
          {...register('email')}
          id="email"
          type="email"
          placeholder="user@example.com"
          aria-invalid={errors.email ? 'true' : 'false'}
        />
        {errors.email && <p className="text-sm text-red-600">{errors.email.message}</p>}
      </div>

      <div className="space-y-2">
        <Label htmlFor="org">Organization</Label>
        <Input
          {...register('organizationName')}
          id="org"
          type="text"
          placeholder="Your organization"
          aria-invalid={errors.organizationName ? 'true' : 'false'}
        />
        {errors.organizationName && <p className="text-sm text-red-600">{errors.organizationName.message}</p>}
      </div>

      <Button type="submit" disabled={isSubmitting} className="w-full">
        {isSubmitting ? 'Registering...' : 'Register'}
      </Button>
    </form>
  )
}
```

#### Validation Features
- Field-level validation: errors display inline
- Real-time validation: set `mode: 'onChange'` if needed
- Custom validation: add to Zod schema
- Async validation: use `.refine()` for API checks
- Error messages: use Zod message parameter for user-friendly text

#### Form Submission Patterns
- Prevent duplicate submissions: use `isSubmitting` state
- Show loading state while submitting
- Handle both success and error states
- Use `try/catch` for error handling
- Redirect or reset form on success

#### Real-Time Form Calculations with `watch()`
- Use `watch()` to observe form field changes in real-time
- Useful for dependent field calculations, live previews, conditional rendering
- Pattern:
```tsx
const pricingStrategy = watch('pricing_strategy')
const pricingAmount = watch('pricing_amount')
const minimumPlayers = watch('minimum_team_players')

// Recalculates whenever watched fields change
const calculatePerPlayerPrice = () => {
  if (!pricingAmount || !minimumPlayers) return null
  if (pricingStrategy === 'per_person') return pricingAmount
  if (pricingStrategy === 'per_team') {
    return Math.ceil(pricingAmount / minimumPlayers)
  }
  return null
}

const perPlayerPrice = calculatePerPlayerPrice()

// Use in JSX
{perPlayerPrice !== null && (
  <div className="bg-blue-50 border border-blue-200 rounded-md p-4">
    <p className="text-sm text-gray-700">
      <span className="font-medium">Estimated price per player:</span>{' '}
      <span className="text-lg font-bold text-blue-600">${perPlayerPrice.toFixed(2)}</span>
    </p>
  </div>
)}
```

### DatePicker Component Pattern
- Create custom DatePicker wrapping shadcn Calendar + Dialog
- Pattern:
```tsx
import { Button } from '@/components/ui/button'
import { Calendar } from '@/components/ui/calendar'
import { Dialog, DialogContent, DialogTitle, DialogTrigger } from '@/components/ui/dialog'
import { format } from 'date-fns'

interface DatePickerProps {
  date?: Date
  onDateChange: (date: Date | undefined) => void
  placeholder?: string
  disabled?: boolean
  className?: string
}

export function DatePicker({
  date,
  onDateChange,
  placeholder = "Pick a date",
  disabled = false,
  className,
}: DatePickerProps) {
  const [open, setOpen] = useState(false)

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        <Button
          variant="outline"
          className={cn("w-full justify-start text-left", !date && "text-muted-foreground", className)}
          disabled={disabled}
        >
          <CalendarIcon className="mr-2 h-4 w-4" />
          {date ? format(date, "MMM d, yyyy") : placeholder}
        </Button>
      </DialogTrigger>
      <DialogContent className="w-auto p-0">
        <DialogTitle className="sr-only">Select a date</DialogTitle>
        <Calendar
          mode="single"
          selected={date}
          onSelect={(selectedDate) => {
            onDateChange(selectedDate)
            setOpen(false)
          }}
          disabled={disabled}
          initialFocus
        />
      </DialogContent>
    </Dialog>
  )
}
```

### Draft Save/Load Pattern
- Load draft on component mount if organization exists
- Populate form fields and date/array state from draft
- Provide "Save Draft" button alongside "Submit" button
- Delete draft after successful submission
- Pattern:
```tsx
// Load draft on mount
useEffect(() => {
  const loadDraft = async () => {
    if (!organizationId || !getToken) {
      setDraftLoading(false)
      return
    }

    try {
      const token = await getToken()
      const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/v1/drafts/${organizationId}`, {
        headers: { Authorization: `Bearer ${token}` },
      })

      if (response.ok) {
        const draftData = await response.json()
        // Populate form fields
        Object.keys(draftData).forEach((key) => {
          const value = draftData[key]
          // Handle dates: parse string to Date
          if ((key === 'season_start_date' || key === 'season_end_date') && value) {
            const parsedDate = parse(value, 'yyyy-MM-dd', new Date())
            setSeasonStartDate(parsedDate) // or similar
          }
          // Handle arrays: restore state
          else if (key === 'game_occurrences' && Array.isArray(value)) {
            setGameOccurrences(value)
          }
          // Handle form values
          else {
            setValue(key as any, value)
          }
        })
      }
    } finally {
      setDraftLoading(false)
    }
  }
  loadDraft()
}, [organizationId, getToken, setValue])

// Save draft handler
const handleSaveDraft = async () => {
  try {
    const token = await getToken()
    const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/v1/drafts`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`,
        'X-Clerk-User-ID': userId,
      },
      body: JSON.stringify({
        org_id: organizationId,
        data: {
          // Include all form values and state
          sport_id: watch('sport_id'),
          league_name: watch('league_name'),
          game_occurrences: gameOccurrences,
          season_start_date: seasonStartDate ? format(seasonStartDate, 'yyyy-MM-dd') : '',
          // ... other fields
        },
      }),
    })
    setDraftSaveStatus('Draft saved successfully')
  } catch (error) {
    setDraftError(error.message)
  }
}

// Delete draft after submission
const onSubmit = async (data: FormData) => {
  // ... submit logic
  await handleDeleteDraft()
}
```

### Clerk Authentication in Forms
- Import `useAuth` from `@clerk/nextjs`
- Always pass token in `Authorization` header and `X-Clerk-User-ID` in custom header
- Pattern:
```tsx
import { useAuth } from '@clerk/nextjs'

export function MyForm() {
  const { getToken, userId } = useAuth()

  const onSubmit = async (data) => {
    const token = await getToken()
    if (!token || !userId) {
      throw new Error('Authentication required')
    }

    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${token}`,
        'X-Clerk-User-ID': userId,
      },
      body: JSON.stringify(data),
    })
  }
}
```

### Components
- Functional components with TypeScript
- Props interface: `interface ComponentProps { ... }`
- **Use shadcn/ui components** for UI elements (Button, Input, Dialog, etc.)
- Only create custom components when shadcn doesn't provide what you need
- Pattern:
```tsx
import { Button } from '@/components/ui/button'

interface CardHeaderProps {
  title: string
  onRefresh?: () => void
}

export function CardHeader({ title, onRefresh }: CardHeaderProps) {
  return (
    <div className="flex items-center justify-between">
      <h2 className="text-lg font-semibold">{title}</h2>
      {onRefresh && <Button onClick={onRefresh} variant="outline">Refresh</Button>}
    </div>
  )
}
```

### Types & Interfaces
- Define in `types/` folder
- Extend Clerk types in `clerk.d.ts`:
```ts
declare global {
  interface CustomJwtSessionClaims extends JwtPayload {
    role?: "admin" | "user";
    emailVerified?: boolean;
  }
}
```
- Use strict TypeScript (no `any`)

### UI Components (shadcn/ui)
- **Always use shadcn/ui components** for consistency and accessibility
- Available components: `Button`, `Input`, `Label`, `Dialog`, `Dropdown Menu`, `Card`, `Tabs`, `Badge`, `Separator`, `Table`, `Input OTP`, `Form`
- Import from `@/components/ui/component-name`
- Pattern:
```tsx
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'

export function MyForm() {
  return (
    <div className="space-y-2">
      <Label htmlFor="email">Email</Label>
      <Input id="email" type="email" placeholder="user@example.com" />
      <Button type="submit">Submit</Button>
    </div>
  )
}
```
- **If a needed component is not available**, inform the user with: "The [ComponentName] component is not available. Please add it to the project and I can use it in the implementation."
- All shadcn components support `className` prop for additional Tailwind styling
- Combine shadcn components with Tailwind utilities for layout and spacing

### Dialog Sizing and Management

#### Responsive Dialog Patterns
- DialogContent has default responsive max-width constraints
- To override: use Tailwind's `!important` flag with `!max-w-*` and `!max-h-*` classes
- Use `w-[Xvw]` for viewport width percentages (e.g., `w-[85vw]`)
- Use `max-h-[95vh]` with `overflow-y-auto` for scrollable tall forms
- Pattern:
```tsx
<Dialog open={openDialog === "league"} onOpenChange={(open) => !open && handleCloseDialog()}>
  <DialogContent className="border-0 !max-w-5xl w-[85vw] max-h-[95vh] overflow-y-auto">
    <DialogHeader className="bg-brand-dark text-white !-mx-6 !-mt-6 !-mb-4 px-6 py-4 rounded-t-lg">
      <DialogTitle className="text-white">Create League</DialogTitle>
      <DialogDescription className="text-gray-200">Create a new league submission.</DialogDescription>
    </DialogHeader>
    <AddLeagueForm onSuccess={onLeagueAdded} onClose={handleCloseDialog} />
  </DialogContent>
</Dialog>
```

#### Important Margin Overrides
- DialogContent has default padding/margins that can push content
- Use `!-mx-6 !-mt-6 !-mb-4` to pull header to edges of dialog
- The `!` flag forces override of DialogContent's padding
- Header should use `rounded-t-lg` to match dialog corners

#### Dialog State Management
- Use single state for multiple dialogs: `const [openDialog, setOpenDialog] = useState<string | null>(null)`
- Handle complex close logic (e.g., prevent close if dropdown is open):
```tsx
<Dialog open={openDialog === "venue"} onOpenChange={(open) => {
  if (!open && !isMapboxDropdownOpen) {
    handleCloseDialog()
  }
}}>
```

### Styling
- Use Tailwind CSS for styling (shadcn components already styled)
- Component-level styling: add `className` prop to shadcn components
- Dark mode: configure in tailwind.config
- Responsive: mobile-first with `sm:`, `md:`, `lg:` prefixes
- Spacing: use Tailwind's `space-y-*` and `space-x-*` for consistent gaps
- Important flag `!` for overriding library defaults: `!max-w-5xl !-mx-6`

### API Communication
- API routes in `/app/api/`
- Fetch with proper error handling
- Always set `Content-Type: application/json`
- Handle auth errors (401 → redirect to /signin)

### Environment Variables
- `NEXT_PUBLIC_*` for client-side
- `.env.local` for secrets (never commit)
- Required: `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY`, `CLERK_SECRET_KEY`

### State Management
- Prefer React hooks (useState, useContext)
- Props for component communication
- Context for global state (auth, theme)
- React Hook Form for form state management
- No Redux/Zustand unless necessary

### Performance
- Code splitting: automatic with Next.js app router
- Image optimization: use `next/image`
- API calls: only when necessary
- Session claims: avoid redundant Clerk API calls

### Testing
- Component tests: React Testing Library
- E2E tests: Playwright
- Test auth flows with Clerk's test mode

### Middleware (proxy.ts)
- Runs on every request
- Read from `sessionClaims` only (no API calls)
- Set up route matchers for protected routes
- Example:
```ts
const isProtectedRoute = createRouteMatcher(['/', '/admin(.*)'])
```

### Comments
- Explain "why" not "what"
- Link to relevant docs for non-obvious patterns
- Component purpose at top: `// AdminDashboard displays metrics for admins`

## Available shadcn/ui Components
**Always use these for UI consistency.** If a component is missing, ask the user to add it.

- `Button` - Interactive buttons with variants (primary, outline, ghost, etc.)
- `Input` - Text input fields with validation support
- `Label` - Form labels with accessibility attributes
- `Dialog` - Modal dialogs for confirmations and forms
- `Dropdown Menu` - Dropdown menus and navigation
- `Card` - Container component for content grouping
- `Tabs` - Tabbed interface for content switching
- `Badge` - Status indicators and tags
- `Separator` - Visual divider lines
- `Table` - Data table component
- `Input OTP` - One-time password input
- `Form` - Form layout component (alternative to manual spacing)

Usage: `import { ComponentName } from '@/components/ui/component-name'`

## Dependencies
- `next@16` - Framework
- `@clerk/nextjs` - Authentication
- `react-hook-form` - Form state management
- `@hookform/resolvers` - Zod integration
- `zod` - Validation schemas
- `tailwindcss` - Styling and utility-first CSS
- `react` - UI library
- `@mapbox/search-js-react` - Mapbox address autocomplete

## Development
- Install: `pnpm install`
- Dev: `pnpm dev`
- Build: `pnpm build`
- Package manager: **pnpm** (not npm/yarn)

## Type Safety
- Extend Clerk types for custom claims
- Use `z.infer<typeof schema>` for form type inference from Zod
- No `as any` unless absolutely necessary
- Use `satisfies` for type narrowing when helpful
- Leverage TypeScript strict mode

## Best Practices
- Keep components small and focused
- Lift state up when multiple components need it
- Use composition over prop drilling
- Error boundaries for graceful failures
- Loading states for async operations
- Validate on both client (Zod) and server (backend)
