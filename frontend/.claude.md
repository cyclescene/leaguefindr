# Claude Code Rules - Frontend (Next.js 16)

## Project Structure
```
/frontend/dashboard
  /app                - App router pages and layouts
    /(admin)          - Admin route group (requires admin role)
    /(auth)           - Auth pages (signin, signup)
  /components         - React components
    /admin            - Admin-specific components
    /forms            - Form components
  /lib                - Utilities
    /schemas          - Zod/validation schemas
  /types              - TypeScript type definitions
  proxy.ts            - Middleware for auth routing
  tsconfig.json       - TypeScript config
```

## Patterns

### App Router Organization
- Route groups: `(admin)`, `(auth)` - logical grouping, not in URL
- Dynamic routes: `[param]` for URL segments
- Middleware: `proxy.ts` handles auth before routes
- Pattern:
```
/app
  /(admin)/admin/page.tsx       → /admin
  /(auth)/signin/page.tsx       → /signin
  /dashboard/page.tsx           → /dashboard
```

### Authentication Flow (Middleware)
- `proxy.ts` orchestrates auth routing
- Read from `sessionClaims` (no API calls)
- Flow:
  1. No userId → redirect to /signin
  2. userId + !emailVerified → redirect to /verify-email
  3. userId + verified + admin → allow /admin
  4. userId + verified + user → allow /dashboard
- Clerk handles actual email verification (frontend reads from native field)

### React Hook Form + Zod Validation

#### Schema Definition
- Define schemas in `lib/schemas/`
- Use Zod for validation and type inference
- Pattern:
```ts
// lib/schemas/auth.ts
import { z } from 'zod'

export const registerSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  organizationName: z.string().min(1, 'Organization name is required')
})

export type RegisterFormData = z.infer<typeof registerSchema>
```

#### Form Component with Validation
- Use `useForm` hook with Zod resolver
- Register fields and handle submission
- Use shadcn/ui components (Input, Label, Button)
- Display validation errors inline
- Pattern:
```tsx
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { registerSchema, type RegisterFormData } from '@/lib/schemas/auth'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Button } from '@/components/ui/button'

export function RegisterForm() {
  const { register, handleSubmit, formState: { errors, isSubmitting } } = useForm<RegisterFormData>({
    resolver: zodResolver(registerSchema)
  })

  const onSubmit = async (data: RegisterFormData) => {
    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      })

      if (!response.ok) {
        throw new Error('Registration failed')
      }

      // Handle success
    } catch (error) {
      console.error('Submit error:', error)
      // Show error to user
    }
  }

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="email">Email</Label>
        <Input
          {...register('email')}
          id="email"
          type="email"
          placeholder="user@example.com"
          aria-invalid={errors.email ? 'true' : 'false'}
        />
        {errors.email && <p className="text-sm text-red-600">{errors.email.message}</p>}
      </div>

      <div className="space-y-2">
        <Label htmlFor="org">Organization</Label>
        <Input
          {...register('organizationName')}
          id="org"
          type="text"
          placeholder="Your organization"
          aria-invalid={errors.organizationName ? 'true' : 'false'}
        />
        {errors.organizationName && <p className="text-sm text-red-600">{errors.organizationName.message}</p>}
      </div>

      <Button type="submit" disabled={isSubmitting} className="w-full">
        {isSubmitting ? 'Registering...' : 'Register'}
      </Button>
    </form>
  )
}
```

#### Validation Features
- Field-level validation: errors display inline
- Real-time validation: set `mode: 'onChange'` if needed
- Custom validation: add to Zod schema
- Async validation: use `.refine()` for API checks
- Error messages: use Zod message parameter for user-friendly text

#### Form Submission Patterns
- Prevent duplicate submissions: use `isSubmitting` state
- Show loading state while submitting
- Handle both success and error states
- Use `try/catch` for error handling
- Redirect or reset form on success

### Components
- Functional components with TypeScript
- Props interface: `interface ComponentProps { ... }`
- **Use shadcn/ui components** for UI elements (Button, Input, Dialog, etc.)
- Only create custom components when shadcn doesn't provide what you need
- Pattern:
```tsx
import { Button } from '@/components/ui/button'

interface CardHeaderProps {
  title: string
  onRefresh?: () => void
}

export function CardHeader({ title, onRefresh }: CardHeaderProps) {
  return (
    <div className="flex items-center justify-between">
      <h2 className="text-lg font-semibold">{title}</h2>
      {onRefresh && <Button onClick={onRefresh} variant="outline">Refresh</Button>}
    </div>
  )
}
```

### Types & Interfaces
- Define in `types/` folder
- Extend Clerk types in `clerk.d.ts`:
```ts
declare global {
  interface CustomJwtSessionClaims extends JwtPayload {
    role?: "admin" | "user";
    emailVerified?: boolean;
  }
}
```
- Use strict TypeScript (no `any`)

### UI Components (shadcn/ui)
- **Always use shadcn/ui components** for consistency and accessibility
- Available components: `Button`, `Input`, `Label`, `Dialog`, `Dropdown Menu`, `Card`, `Tabs`, `Badge`, `Separator`, `Table`, `Input OTP`, `Form`
- Import from `@/components/ui/component-name`
- Pattern:
```tsx
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'

export function MyForm() {
  return (
    <div className="space-y-2">
      <Label htmlFor="email">Email</Label>
      <Input id="email" type="email" placeholder="user@example.com" />
      <Button type="submit">Submit</Button>
    </div>
  )
}
```
- **If a needed component is not available**, inform the user with: "The [ComponentName] component is not available. Please add it to the project and I can use it in the implementation."
- All shadcn components support `className` prop for additional Tailwind styling
- Combine shadcn components with Tailwind utilities for layout and spacing

### Styling
- Use Tailwind CSS for styling (shadcn components already styled)
- Component-level styling: add `className` prop to shadcn components
- Dark mode: configure in tailwind.config
- Responsive: mobile-first with `sm:`, `md:`, `lg:` prefixes
- Spacing: use Tailwind's `space-y-*` and `space-x-*` for consistent gaps

### API Communication
- API routes in `/app/api/`
- Fetch with proper error handling
- Always set `Content-Type: application/json`
- Handle auth errors (401 → redirect to /signin)

### Environment Variables
- `NEXT_PUBLIC_*` for client-side
- `.env.local` for secrets (never commit)
- Required: `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY`, `CLERK_SECRET_KEY`

### State Management
- Prefer React hooks (useState, useContext)
- Props for component communication
- Context for global state (auth, theme)
- React Hook Form for form state management
- No Redux/Zustand unless necessary

### Performance
- Code splitting: automatic with Next.js app router
- Image optimization: use `next/image`
- API calls: only when necessary
- Session claims: avoid redundant Clerk API calls

### Testing
- Component tests: React Testing Library
- E2E tests: Playwright
- Test auth flows with Clerk's test mode

### Middleware (proxy.ts)
- Runs on every request
- Read from `sessionClaims` only (no API calls)
- Set up route matchers for protected routes
- Example:
```ts
const isProtectedRoute = createRouteMatcher(['/', '/admin(.*)'])
```

### Comments
- Explain "why" not "what"
- Link to relevant docs for non-obvious patterns
- Component purpose at top: `// AdminDashboard displays metrics for admins`

## Available shadcn/ui Components
**Always use these for UI consistency.** If a component is missing, ask the user to add it.

- `Button` - Interactive buttons with variants (primary, outline, ghost, etc.)
- `Input` - Text input fields with validation support
- `Label` - Form labels with accessibility attributes
- `Dialog` - Modal dialogs for confirmations and forms
- `Dropdown Menu` - Dropdown menus and navigation
- `Card` - Container component for content grouping
- `Tabs` - Tabbed interface for content switching
- `Badge` - Status indicators and tags
- `Separator` - Visual divider lines
- `Table` - Data table component
- `Input OTP` - One-time password input
- `Form` - Form layout component (alternative to manual spacing)

Usage: `import { ComponentName } from '@/components/ui/component-name'`

## Dependencies
- `next@16` - Framework
- `@clerk/nextjs` - Authentication
- `react-hook-form` - Form state management
- `@hookform/resolvers` - Zod integration
- `zod` - Validation schemas
- `tailwindcss` - Styling and utility-first CSS
- `react` - UI library
- `@mapbox/search-js-react` - Mapbox address autocomplete

## Development
- Install: `pnpm install`
- Dev: `pnpm dev`
- Build: `pnpm build`
- Package manager: **pnpm** (not npm/yarn)

## Type Safety
- Extend Clerk types for custom claims
- Use `z.infer<typeof schema>` for form type inference from Zod
- No `as any` unless absolutely necessary
- Use `satisfies` for type narrowing when helpful
- Leverage TypeScript strict mode

## Best Practices
- Keep components small and focused
- Lift state up when multiple components need it
- Use composition over prop drilling
- Error boundaries for graceful failures
- Loading states for async operations
- Validate on both client (Zod) and server (backend)
